
import:
	java.util.HashMap
	
using for loops

function eval(expr: struct, env: struct) :: objects:
	set {_type} to {_expr}->type

	if {_type} = {SExpressionType}->INTEGER:
		return {_expr}->value

	else if {_type} = {SExpressionType}->SYMBOL:
		return {_env}->variables.get({_expr}->value)

	else if {_type} = {SExpressionType}->BOOLEAN:
		return {_expr}->value

	else if {_type} = {SExpressionType}->STRING:
		return {_expr}->value

	else if {_type} = {SExpressionType}->LIST:
		set {_items::*} to {_expr}->value
		set {_head} to {_items::1}

		if {_head}->type != {SExpressionType}->SYMBOL:
			throw runtime warning "Expected function name or special form, got %{_head}->type%"

		set {_name} to 1st element of {_head}->value

		if {_env}->special_forms.containsKey({_name}):
			# sm_log("special_form {1}", {_name})
			return eval_special_form({_name}, {_items::*}, {_env})

		set {_op} to 1st element of eval({_items::1}, {_env})

		for {_i} in range(2, size of {_items::*}):
			set {_args::*} to {_args::*}, eval({_items::%{_i}%}, {_env})

		# sm_log("function {1}, (op: [2], args: [3], items: [4])", ({_name}, {_op}, "%{_args::*}%", "%{_items::*}%"))
		return call_function({_op}, {_args::*}, {_env})

		

	throw runtime warning "Unknown expression type %{_type}%"

function eval_special_form(name: string, items: objects, env: struct) :: object:
	if {_name} = "define":
		set {_symbol_expr} to {_items::2}
		if {_symbol_expr}->type != {SExpressionType}->SYMBOL:
			throw runtime warning "define: expected symbol"
		set {_symbol} to 1st element of {_symbol_expr}->value
		set {_value} to 1st element of eval({_items::3}, {_env})
		{_env}->variables.put({_symbol}, {_value})
		return {_value}
	
	else if {_name} = "if":
		set {_condition} to 1st element of eval({_items::2}, {_env})
		if {_condition} is true:
			return 1st element of eval({_items::3}, {_env})
		return 1st element of eval({_items::4}, {_env})

	else if {_name} = "and":
		loop range(2, size of {_items::*}):
			set {_result} to 1st element of eval({_items::%loop-value%}, {_env})
			return false if {_result} != true
		return true

	else if {_name} = "or":
		loop range(2, size of {_items::*}):
			set {_result} to 1st element of eval({_items::%loop-value%}, {_env})
			return true if {_result} = true
		return false

	else if {_name} = "not":
		set {_result} to 1st element of eval({_items::2}, {_env})
		if {_result} = true:
			return false
		return true

	throw runtime warning "Unknown special form %{_name}%"

function call_function(func: string, args: objects, env: struct) :: object:
	if {_func} is "+":
		return sum({_args::*})
	else if {_func} is "*":
		return product({_args::*})
	else if {_func} is "-":
		return ({_args::1} - {_args::2})
	else if {_func} is "/":
		return ({_args::1} / {_args::2})
	else if {_func} is "^":
		return ({_args::1} ^ {_args::2})
	else if {_func} is "reverse":
		return (join (reversed ({_args::1} split at "")))
	else if {_func} is "print":
		return builtin_print({_args::*})	
	throw runtime warning "Unknown function %{_func}%"

function builtin_print(args: objects) :: object:
	for {_arg} in {_args::*}:
		broadcast {_arg}