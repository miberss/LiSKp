import:
	java.util.HashMap
	
using for loops
using script reflection

function eval(expr: struct, env: struct) :: objects:
	set {_type} to {_expr}->type

	# sm_log("%{_type}%")

	if {_type} = {SExpressionType}->INTEGER, {SExpressionType}->STRING, or {SExpressionType}->BOOLEAN:
		return {_expr}->value

	else if {_type} = {SExpressionType}->SYMBOL:
		return find_through_closures({_expr}, {_env})

	else if {_type} = {SExpressionType}->LIST:
		set {_items::*} to {_expr}->value
		set {_head} to {_items::1}

		set {_name} to 1st element of {_head}->value
		# sm_log("{1}", "%{_name}%")
		set {_forms} to {_env}->special_forms
		if {_forms}.containsKey({_name}):
			# sm_log("special_form {1}", {_name})
			return call_special_form({_forms}.get({_name}), {_items::*}, {_env})

		set {_op::*} to eval({_items::1}, {_env})

		for {_i} in range(2, size of {_items::*}):
			set {_args::*} to {_args::*}, eval({_items::%{_i}%}, {_env})
		
		# sm_log("item::1 [1] ([2])", ("%{_items::1}%", "%debug_dump({_items::1})%"))

		set {_op} to ({_op::1} ? 1st element of {_items::1}->value)

		# sm_log("function {1}, (op: [2], args: [3], items: [4])", ("%{_name}%", "%{_op}%", "%{_args::*}%", "%{_items::*}%"))
		#set {_now} to (unix timestamp of now)
		set {_a::*} to call_function({_op}, {_args::*})
		#set {_delay} to "%((unix timestamp of now) - {_now}) * 1000%ms"
		#sm_log( "executed {1} with args [2] took [3]", ({_op}, "%{_args::*}%", {_delay}) )
		return {_a::*}

	throw runtime warning "Unknown expression type %{_type}%"

function find_through_closures(expr: struct, env: struct, depth: integer = 0) :: object:
	set {_depth} to {_depth} + 1
	if {_depth} > 16:
		# sm_log("searched too deep [1]", "%{_expr}->value%")
		stop
	set {_var} to {_env}->variables.get({_expr}->value)
	if {_var} is not set:
		if {_env}->parent is not set:
			throw runtime warning "Unknown symbol %{_expr}->value% in %{_env}->id%"
			return {_}
		return find_through_closures({_expr}, {_env}->parent, {_depth})
	# sm_log("found symbol [1]", "%{_expr}->value%, value: %{_var}%")
	return {_var}

function new_env(parent: struct, id: string = {_}) :: struct:
	set {_env} to Environment({_id})
	set {_env}->parent to {_parent}
	set {_env}->variables to new HashMap()
	set {_env}->special_forms to ({_parent}->special_forms)
	return {_env}



function call_function(func: object, args: objects) :: objects:
	if template of {_func} = "function":
		set {_local_env} to new_env({_func}->env, "%{_func}->id%_execute")
		for {_i}, {_param} in {_func}->params:
			{_local_env}->variables.put({_param}, {_args::%{_i}%})
		# sm_log("Called a Lambda: Body: [1], Variables: [2], Params: [3]", ({_func}->body->value, {_func}->env->variables, {_func}->params))
		# dump_env_tree({_local_env})
		return eval({_func}->body, {_local_env})
	
	set {_fn} to function "builtin_%{_func}%" from script "lisp/builtins"
	if {_fn} is not set:
		throw runtime warning "Unknown function %{_func}%"
	return results of {_fn} with arguments [{_args::*}]

function dump_env_tree(env: struct, depth: integer = 1):
	set {_indent} to "  " repeated {_depth} times
	sm_log("%{_indent}%[1] â‡’ [2]", ("%{_env}->id%", "%{_env}->variables.keySet()%"))
	if {_env}->parent is set:
		dump_env_tree({_env}->parent, {_depth} + 1)
